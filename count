		[CCode (cname = "SDL_Keycode", cprefix = "SDLK_", cheader_filename = "SDL2/SDL_keyboard.h")]
		public enum Keycode {
			UNKNOWN, RETURN, ESCAPE, BACKSPACE, TAB, SPACE, EXCLAIM,
			QUOTEDBL, HASH, PERCENT, DOLLAR, AMPERSAND, QUOTE,
			LEFTPAREN, RIGHTPAREN, ASTERISK, PLUS, COMMA, MINUS,
			PERIOD, SLASH, SDLK_0, SDLK_1, SDLK_2, SDLK_3, SDLK_4,
			SDLK_5, SDLK_6, SDLK_7, SDLK_8, SDLK_9, COLON, SEMICOLON,
			LESS, EQUALS, GREATER, QUESTION, AT, LEFTBRACKET, BACKSLASH,
			RIGHTBRACKET, CARET, UNDERSCORE, BACKQUOTE, a, b, c, d, e, f,
			g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, CAPSLOCK, F1,
			F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, PRINTSCREEN,
			SCROLLLOCK, PAUSE, INSERT, HOME, PAGEUP, DELETE, END,
			PAGEDOWN, RIGHT, LEFT, DOWN, UP, NUMLOCKCLEAR, KP_DIVIDE,
			KP_MULTIPLY, KP_MINUS, KP_PLUS, KP_ENTER, KP_1, KP_2, KP_3,
			KP_4, KP_5, KP_6, KP_7, KP_8, KP_9, KP_0, KP_PERIOD, APPLICATION,
			POWER, KP_EQUALS, F13, F14, F15, F16, F17, F18, F19, F20, F21,
			F22, F23, F24, EXECUTE, HELP, MENU, SELECT, STOP, AGAIN, UNDO,
			CUT, COPY, PASTE, FIND, MUTE, VOLUMEUP, VOLUMEDOWN, KP_COMMA,
			KP_EQUALSAS400, ALTERASE, SYSREQ, CANCEL, CLEAR, PRIOR,
			RETURN2, SEPARATOR, OUT, OPER, CLEARAGAIN, CRSEL, EXSEL,
			KP_00, KP_000, THOUSANDSSEPARATOR, DECIMALSEPARATOR,
			CURRENCYUNIT, CURRENCYSUBUNIT, KP_LEFTPAREN, KP_RIGHTPAREN,
			KP_LEFTBRACE, KP_RIGHTBRACE, KP_TAB, KP_BACKSPACE, KP_A, KP_B,
			KP_C, KP_D, KP_E, KP_F, KP_XOR, KP_POWER, KP_PERCENT, KP_LESS,
			KP_GREATER, KP_AMPERSAND, KP_DBLAMPERSAND, KP_VERTICALBAR,
			KP_DBLVERTICALBAR, KP_COLON, KP_HASH, KP_SPACE, KP_AT,
			KP_EXCLAM, KP_MEMSTORE, KP_MEMRECALL, KP_MEMCLEAR, KP_MEMADD,
			KP_MEMSUBTRACT, KP_MEMMULTIPLY, KP_MEMDIVIDE, KP_PLUSMINUS,
			KP_CLEAR, KP_CLEARENTRY, KP_BINARY, KP_OCTAL, KP_DECIMAL,
			KP_HEXADECIMAL, LCTRL, LSHIFT, LALT, LGUI, RCTRL, RSHIFT, RALT,
			RGUI, MODE, AUDIONEXT, AUDIOPREV, AUDIOSTOP, AUDIOPLAY,
			AUDIOMUTE, MEDIASELECT, WWW, MAIL, CALCULATOR, COMPUTER,
			AC_SEARCH, AC_HOME, AC_BACK, AC_FORWARD, AC_STOP, AC_REFRESH,
			AC_BOOKMARKS, BRIGHTNESSDOWN, BRIGHTNESSUP, DISPLAYSWITCH,
			KBDILLUMTOGGLE, KBDILLUMDOWN, KBDILLUMUP, EJECT, SLEEP
		}// Keycodeusing SDL;
namespace LAIR{
	class Room : Object{
		private bool visited = false;
		private List<Entity> Particles = new List<Entity>();
		private Entity Player = null;
		private List<Entity> Mobs = new List<Entity>();
                private GLib.Rand DungeonMaster = new GLib.Rand ();
		//public Room(int width, int height, FileDB* DM, Video.Renderer? renderer){
                public Room(int width, int height, FileDB DM, Video.Renderer? renderer, int[] xyoffset){
                        int WT = (width / 32); int HT = (height / 32);
                        stdout.printf("    Generating room. Width: %s ", WT.to_string()); stdout.printf("Height %s \n", HT.to_string());
                        GenerateStructure(DM, WT,HT, 2, xyoffset, renderer);
                        stdout.printf("    Generated room. Length: %s\n", Particles.length().to_string());
		}
		//public Room.WithPlayer(int width, int height, FileDB* DM, Video.Renderer? renderer){
                public Room.WithPlayer(int width, int height, FileDB DM, Video.Renderer? renderer, int[] xyoffset){
                        int WT = (width / 32); int HT = (height / 32);
                        stdout.printf("    Generating room with Player. Width: %s ", WT.to_string()); stdout.printf("Height %s\n", HT.to_string());
                        GenerateStructure(DM, WT,HT, 2, xyoffset, renderer);
                        EnterRoom(new Entity.Player(Video.Point(){x = 128, y = 128}, DM.BodyByTone("med"), DM.GetRandSound(), DM.GetRandFont(), renderer));
                        stdout.printf("    Generated room. Length: %s\n", Particles.length().to_string());
		}
                private void GenerateStructure(FileDB DM, int WT, int HT, int CR=2, int[] xyoffset, Video.Renderer* renderer){
                        for (int x = 0; x < WT; x++){
                                for (int y = 0; y < HT; y++){
                                        int XO = (x * 32) + xyoffset[0]; int YO = (y * 32) + xyoffset[1];
                                        Particles.append(new Entity(Video.Point(){ x = XO, y = YO }, DM.ImageByName("stonefloor"), DM.GetRandSound(), DM.GetRandFont(), renderer));
                                        stdout.printf("     Generating Entity Particle X: %s ", XO.to_string()); stdout.printf("Y: %s \n", YO.to_string());
                                        if ( x == (0 + DungeonMaster.int_range(0,CR)) ){
                                                Particles.append(new Entity.Blocked(Video.Point(){ x = XO, y = YO }, DM.ImageByName("stonewall"), DM.GetRandSound(), DM.GetRandFont(), renderer));
                                        }else if ( x == ((WT-1) - DungeonMaster.int_range(0,CR)) ){
                                                Particles.append(new Entity.Blocked(Video.Point(){ x = XO, y = YO }, DM.ImageByName("stonewall"), DM.GetRandSound(), DM.GetRandFont(), renderer));
                                        }else if ( y == (0 + DungeonMaster.int_range(0,CR)) ){
                                                Particles.append(new Entity.Blocked(Video.Point(){ x = XO, y = YO }, DM.ImageByName("stonewall"), DM.GetRandSound(), DM.GetRandFont(), renderer));
                                        }else if ( y == ((HT-1) - DungeonMaster.int_range(0,CR)) ){
                                                Particles.append(new Entity.Blocked(Video.Point(){ x = XO, y = YO }, DM.ImageByName("stonewall"), DM.GetRandSound(), DM.GetRandFont(), renderer));
                                        }
                                }
                        }
                }
                public int TakeTurns(){
                        int tmp = 1;
                        stdout.printf("    Entities in the room are taking turns\n");
                        if (HasPlayer()){
                                tmp = (tmp != 1) ? tmp : Player.run();
                        }else{
                                foreach(Entity mob in Mobs){
					mob.run();
				}
                        }
                        return tmp;
                }
		public void RenderCopy(Video.Renderer renderer){
                        stdout.printf("   Rendering Room.\n");
			if (visited){
                                stdout.printf("    Rendering Particles. \n");
				foreach(Entity particle in Particles){
					particle.RenderCopy(renderer);
				}
			}
                        if (HasPlayer()){
                                stdout.printf("    Rendering Player. \n");
				Player.RenderCopy(renderer);
				if (visited = false){
					visited = true;
				}
                                stdout.printf("    Rendering Mobs. \n");
				foreach(Entity mob in Mobs){
					mob.RenderCopy(renderer);
				}
			}
		}
		public bool EnterRoom(Entity player){
			if (player != null){
                                stdout.printf("    Player Entering Room. \n");
				Player = player;
                                visited = true;
			}
			return visited;
		}
		public Entity LeaveRoom(){
			Entity tmp = Player;
			Player = null;
			return tmp;
		}
		public bool HasPlayer(){
			bool tmp = false;
			if (Player != null){
				tmp = (Player != null) ? (Player != null) : false;
                                visited = true;
			}
			return tmp;
		}
	}
}
using SDL;
namespace LAIR{
	class Tower : Object{
		private List<Floor> floors = new List<Floor>();
		public Tower(string size, FileDB DM, Video.Renderer? renderer){
			int w = 320;
			int h = 320;
			int count = 10;
			if (size == "giant"){
				w = 2560;
				h = 2560;
				count = 6;
			}else if (size == "large"){
				w = 1280;
				h = 1280;
				count = 5;
			}else if (size == "medium"){
				w = 640;
				h = 640;
				count = 4;
			}else if (size == "small"){
				w = 480;
				h = 480;
				count = 2;
			}else if (size == "tiny"){
				w = 320;
				h = 320;
				count = 2;
			}
                        stdout.printf("Building %s-size Tower\n", size);
			for (int c = 0; c <= count-1; c++){
                                stdout.printf(" Creating new floor :%s\n", c.to_string());
                                if (c == 0){
                                        floors.append(new Floor.WithPlayer(w, h, count, 0, DM, renderer));
                                }else{
                                        floors.append(new Floor(w, h, count, DM, renderer));
                                }
			}
		}
                public int TakeTurns(){
                        int tmp = 1;
                        stdout.printf(" Entities in the tower are taking turns.\n");
                        foreach(Floor floor in floors){
                                tmp = (tmp != 1) ? tmp : floor.TakeTurns();
                        }
                        return tmp;
                }
		public void RenderCopy(Video.Renderer renderer){
                        stdout.printf(" Rendering Tower.\n");
			foreach(Floor floor in floors){
				floor.RenderCopy(renderer);
			}
		}
	}
}
using SDL;
using SDLGraphics;
using SDLImage;
using SDLTTF;
using SDLMixer;

namespace LAIR{
	class Game{
		private Video.Window window;
		private Video.Renderer WindowRenderer;

		private FileDB Resources;
		private Tower GameEnvironment;

		public Game(string imageListPath, string soundListPath, string fontsListPath, string mapSize, int screenW, int screenH) {
			window = new Video.Window("LAIR!", Video.Window.POS_CENTERED, Video.Window.POS_CENTERED, screenW, screenH, Video.WindowFlags.SHOWN);
			WindowRenderer = Video.Renderer.create(window, -1, Video.RendererFlags.ACCELERATED | Video.RendererFlags.PRESENTVSYNC);
                        window.show();
			assert(WindowRenderer != null);

                        int imgInitFlags = SDLImage.InitFlags.PNG;
                        int initResult = SDLImage.init(imgInitFlags);
                        if ((initResult & imgInitFlags) != imgInitFlags) {
                                //stdout.printf("SDL_image could not initialize! SDL_image Error: %s\n", SDLImage.get_error());
                                //return false;
                        }
                        //return true;

                        Resources = new FileDB(imageListPath, soundListPath, fontsListPath);
                        GameEnvironment = new Tower(mapSize, Resources, WindowRenderer);
		}
		private int UpdateScreen(){
			int r = GameEnvironment.TakeTurns();
			GameEnvironment.RenderCopy(WindowRenderer);
			WindowRenderer.present();
			return r;
		}
		public int run(){
			int exit = 1;
			while(exit != 0){
                                WindowRenderer.set_draw_color(0xFF, 0xFF, 0xFF, Video.Alpha.TRANSPARENT);
                                WindowRenderer.clear();
				exit = UpdateScreen();
                                stdout.printf(" -> input was:%s\n", exit.to_string());
                                SDL.Timer.delay(125);
			}
			return exit;
		}
	}
}
using SDL;
namespace LAIR{
	class Floor : Object{
		private List<Room> rooms = new List<Room>();
		public Floor(int width, int height, int count, FileDB DM, Video.Renderer? renderer){
			for (int x = 1; x <= count; x++){
                                for (int y = 1; y <= count; y++){
                                        int [2] xyo = {(x*width)-width, (y*height)-height};
                                        stdout.printf("<< generating room\n");
                                        rooms.append(new Room(width, height, DM, renderer, xyo));
                                }
			}
		}
		public Floor.WithPlayer(int width, int height, int count, int entry, FileDB DM, Video.Renderer? renderer){
                        int c = 0;
			for (int x = 1; x <= count; x++){
                                for (int y = 1; y <= count; y++){
                                        int [2] xyo = {(x*width)-width, (y*height)-height};
                                        stdout.printf("<< count %s \n", c.to_string());
                                        if (c == entry){
                                                stdout.printf("<< generating room with player\n");
                                                rooms.append(new Room.WithPlayer(width, height, DM, renderer, xyo));
                                        }else{
                                                stdout.printf("<< generating room\n");
                                                rooms.append(new Room(width, height, DM, renderer, xyo));
                                        }
                                        c++;
                                }
			}
                }
		private bool HasPlayer(){
			bool tmp = false;
			foreach(Room room in rooms){
				tmp = tmp ? tmp : room.HasPlayer();
			}
			return tmp;
		}
                public int TakeTurns(){
                        int tmp = 1;
                        foreach(Room room in rooms){
                                stdout.printf("   Entities on the floor are taking turns\n");
                                tmp = (tmp != 1) ? tmp : room.TakeTurns();
                        }
                        return tmp;
                }
		public void RenderCopy(Video.Renderer renderer){
                        stdout.printf("   Rendering Floor.\n");
                        if (HasPlayer()){
                                foreach(Room room in rooms){
                                        room.RenderCopy(renderer);
                                }
                        }
		}
	}
}
using SDL;
using SDLGraphics;
using SDLImage;
using SDLTTF;
using SDLMixer;

namespace LAIR{
	public class Lair {
		private Game GameMap;
		public Lair(string imageListPath, string soundListPath, string fontsListPath, string mapSize, int screenW, int screenH){
                        if (SDL.init (SDL.InitFlag.EVERYTHING| SDLImage.InitFlags.ALL) > 0){
                                //log some shit here.
                        }
                        if (SDLImage.init(SDLImage.InitFlags.PNG) < 0) {
                                //log some more shit.
                        }
			SDLTTF.init();

			GameMap = new Game(imageListPath, soundListPath, fontsListPath, mapSize, screenW, screenH);
			GameMap.run();
		}
		~Lair() {
			SDL.quit();
		}
		public static void main(string args[]){
			string ImageFilePath = "/usr/share/lair/images.list";
			string SoundFilePath = "/usr/share/lair/sounds.list";
			string FontsFilePath = "/usr/share/lair/fonts.list";
			List<string> Arguments = new List<string>();
			string MapSize = "tiny";
			int PixelW = 800;
			int PixelH = 600;
			foreach(string arg in args){
				Arguments.append(arg);
			}
			for (int index = 0; index < Arguments.length(); index++){
				stdout.printf(Arguments.nth_data(index));
				stdout.printf("\n");
				switch (Arguments.nth_data(index)){
					case "-i":
						ImageFilePath = Arguments.nth_data(index+1);
						break;
					case "-s":
						SoundFilePath = Arguments.nth_data(index+1);
						break;
					case "-f":
						FontsFilePath = Arguments.nth_data(index+1);
						break;
					case "-m":
						MapSize = Arguments.nth_data(index+1);
						break;
					case "-w":
						PixelW = Arguments.nth_data(index+1).to_int();
						break;
					case "-h":
						PixelH = Arguments.nth_data(index+1).to_int();
						break;
					default:
						break;
				}
			}
			stdout.printf("Image file path from options: %s \n", ImageFilePath);
			stdout.printf("Sound file path from options: %s \n", SoundFilePath);
			stdout.printf("Font file path from options: %s \n", FontsFilePath);
			var app = new Lair(ImageFilePath, SoundFilePath, FontsFilePath, MapSize, PixelW, PixelH);
		}
	}
}
namespace LAIR{
	public class Type : Object{
		private bool player = false;
                private int b = 0;
                private List<string> tags = new List<string>();
                public Type(){
                        player = false;
                        b = 0;
                        tags = new List<string>();
                        SetType("default");
                }
                public Type.Blocked(){
                        SetType("blocked");
		}
                public Type.Parameter(string type){
                        SetType(type);
                        player = CheckType("player");
                        if (player) {
                                SetType("blocked");
                        }
                }
                public Type.ParameterList(List<string> types){
                        foreach(string type in types.copy()){
                                SetType(type);
                        }
                        player = CheckType("player");
                        if (player) {
                                SetType("blocked");
                        }
                }
                public Type.ParameterBlocked(string type){
                        SetType("blocked");
                        SetType(type);
                        player = CheckType("player");
                }
                public Type.ParameterListBlocked(List<string> types){
                        SetType("blocked");
                        foreach(string type in types.copy()){
                                SetType(type);
                        }
                        player = CheckType("player");
                }
		public bool SetType(string NewType){
                        bool t = true;
                        foreach(string i in tags.copy()){
                                if ( i == NewType ){
                                        t = false;
                                }
                        }
                        if (t){
                                tags.append(NewType);
                                stdout.printf("   Added tag: %s \n", NewType);
                                b = 0;
                        }
                        if ( NewType == "blocked" ){
                                b = 1;
                        }
                        if ( NewType == "player" ){
                                player = true;
                        }
                        return t;
		}
                public bool CheckType(string Type){
                        bool r = false;
                        foreach(string i in tags.copy()){
                                if ( i == Type ){
                                        r = true;
                                }
                        }
                        return r;
                }
		public bool GetBlock(){
                        bool r = false;
                        if ( b == 0 ){
                                r = CheckType("blocked");
                                if ( r == true){
                                        b = 1;
                                }
                        }else if ( b == 1 ){
                                r = true;
                        }

			return r;
		}
		public bool IsPlayer(){
			return player;
		}
	}
}
using SDL;
using SDLImage;
using SDLGraphics;

namespace LAIR{
	public class Sprite : Anim{
                private List<Video.Texture> body = new List<Video.Texture>();
                public Sprite(Video.Point corner, List<Video.Surface*> Surfaces, Video.Renderer? renderer){
                        base(Video.Rect(){x=corner.x, y=corner.y, w=32, h=32});
                        foreach (var surface in Surfaces){
                                body.append(Video.Texture.create_from_surface(renderer, surface));
                                assert(body.nth_data(body.length()-1) != null);
                                body.nth_data(body.length()-1).set_blend_mode(Video.BlendMode.BLEND);
                                stdout.printf("Number of images in stack %s \n", body.length().to_string());
                        }
                }
                public Sprite.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, Video.Renderer? renderer){
                        base.Blocked(Video.Rect(){x=corner.x, y=corner.y, w=32, h=32});
                        foreach (var surface in Surfaces){
                                body.append(Video.Texture.create_from_surface(renderer, surface));
                                assert(body.nth_data(body.length()-1) != null);
                                body.nth_data(body.length()-1).set_blend_mode(Video.BlendMode.BLEND);
                                stdout.printf("Number of images in stack %s \n", body.length().to_string());
                        }
                }
                public Sprite.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, Video.Renderer? renderer, string tag){
                        base.Parameter(Video.Rect(){x=corner.x, y=corner.y, w=32, h=32}, tag);
			foreach (var surface in Surfaces){
                                body.append(Video.Texture.create_from_surface(renderer, surface));
                                assert(body.nth_data(body.length()-1) != null);
                                body.nth_data(body.length()-1).set_blend_mode(Video.BlendMode.BLEND);
                                stdout.printf("Number of images in stack %s \n", body.length().to_string());
                        }
		}
                public Sprite.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(Video.Rect(){x=corner.x, y=corner.y, w=32, h=32}, tag);
			foreach (var surface in Surfaces){
                                body.append(Video.Texture.create_from_surface(renderer, surface));
                                assert(body.nth_data(body.length()-1) != null);
                                body.nth_data(body.length()-1).set_blend_mode(Video.BlendMode.BLEND);
                                stdout.printf("Number of images in stack %s \n", body.length().to_string());
                        }
		}
                public Sprite.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(Video.Rect(){x=corner.x, y=corner.y, w=32, h=32}, tags);
			foreach (var surface in Surfaces){
                                body.append(Video.Texture.create_from_surface(renderer, surface));
                                assert(body.nth_data(body.length()-1) != null);
                                body.nth_data(body.length()-1).set_blend_mode(Video.BlendMode.BLEND);
                                stdout.printf("Number of images in stack %s \n", body.length().to_string());
                        }
		}
                public Sprite.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(Video.Rect(){x=corner.x, y=corner.y, w=32, h=32}, tags);
			foreach (var surface in Surfaces){
                                body.append(Video.Texture.create_from_surface(renderer, surface));
                                assert(body.nth_data(body.length()-1) != null);
                                body.nth_data(body.length()-1).set_blend_mode(Video.BlendMode.BLEND);
                                stdout.printf("Number of images in stack %s \n", body.length().to_string());
                        }
		}
		public void RenderCopy(Video.Renderer* renderer){
                        int c = 0;
                        foreach(var texture in body.copy()){
                                stdout.printf("Rendering a layered texture: %s\n",c.to_string());
                                renderer->copyex(texture, GetSource(), GetPosition(), GetAngle(GetCenter()), GetCenter(), Video.RendererFlip.NONE);
                                c++;
                        }

		}
	}
}
using SDL;
using SDLMixer;
using SDLTTF;
namespace LAIR{
	class Entity : Move{
                public Entity(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer ){
                        base(corner, Surfaces, music, font, renderer);
                }
                public Entity.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer){
                        base.Blocked(corner, Surfaces, music, font, renderer);
                }
                public Entity.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.Parameter(corner, Surfaces, music, font, renderer, tag);
                }
                public Entity.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(corner, Surfaces, music, font, renderer, tag);
                }
                public Entity.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(corner, Surfaces, music, font, renderer, tags);
                }
                public Entity.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(corner, Surfaces, music, font, renderer, tags);
                }
                public Entity.Player(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer ){
                        base.Parameter(corner, Surfaces, music, font, renderer, "player");
                }
                public bool DetectCollision(Entity t){
                        bool r = false;
                        //int[2] bottomRightA = { (int) GetX()+GetWidth(), (int) GetY()+GetHeight() };
//                        int[2] bottomRightB = { (int) t.GetX()+t.GetWidth(), (int) t.GetY()+t.GetHeight() };
                        int x = 0; int y = 1;
                        bool test = false;
                        test = (t.GetHitBox().x + t.GetHitBox().w < GetHitBox().x)      ? false : true;
                        test = (t.GetHitBox().x > GetHitBox().x + GetHitBox().w)        ? test : true ;
                        test = (t.GetHitBox().y + t.GetHitBox().h < GetHitBox().y)      ? test : true ;
                        test = (t.GetHitBox().y > GetHitBox().y + GetHitBox().h)        ? test : true;
                        /*
                        bool boxOnly = ((bottomRightB[x] < GetX()) || (bottomRightA[x] < t.GetX())) ? false: true;
                        boxOnly = ((bottomRightB[y] < GetY()) || (bottomRightA[y] < t.GetY())) ? boxOnly: true;
                        if (boxOnly){
                                int[2] xse = {
                                (GetX() > t.GetX()) ? GetX() : t.GetX() ,
                                (bottomRightA[x] > bottomRightB[x]) ? bottomRightA[x] : bottomRightB[x]
                                };
                                int[2] yse = {
                                (GetY() > t.GetY()) ? GetY() : t.GetY() ,
                                (bottomRightA[y] > bottomRightB[y]) ? bottomRightA[y] : bottomRightB[y]
                                };
                        }*/
                        return r;
                }
	}
}
using SDL;
using SDLMixer;
using SDLTTF;

namespace LAIR{
	class Net : Voice{
                public Net(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer ){
                        base(corner, Surfaces, music, font, renderer);
                }
                public Net.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer){
                        base.Blocked(corner, Surfaces, music, font, renderer);
                }
                public Net.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.Parameter(corner, Surfaces, music, font, renderer, tag);
                }
                public Net.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(corner, Surfaces, music, font, renderer, tag);
                }
                public Net.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(corner, Surfaces, music, font, renderer, tags);
                }
                public Net.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(corner, Surfaces, music, font, renderer, tags);
                }
	}
}
using SDL;
using SDLMixer;
using SDLTTF;
namespace LAIR{
	class Stats : Net{
		private int Strength = 10;
		private int Agility = 10;
		/*private int Toughness = 10;
		private int Intelligence = 10;
		private int Special = 10;*/
		private int speed = 0;/*
		private int exert = 0;
		private int dodge = 0;
		private int aim = 0;
		private int will = 0;
		private int resist = 0;
		private int magic = 0;
		private int tech = 0;*/
                public Stats(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer ){
                        base(corner, Surfaces, music, font, renderer);
                }
                public Stats.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer){
                        base.Blocked(corner, Surfaces, music, font, renderer);
                }
                public Stats.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.Parameter(corner, Surfaces, music, font, renderer, tag);
                }
                public Stats.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(corner, Surfaces, music, font, renderer, tag);
                }
                public Stats.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(corner, Surfaces, music, font, renderer, tags);
                }
                public Stats.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(corner, Surfaces, music, font, renderer, tags);
                }
		public int Speed(){
			int tmp = (Strength + Agility) / 4;
			return tmp + speed;
		}/*
		public int Exert(){
			int tmp = (Strength + Toughness) / 4;
			return tmp + exert;
		}
		public int Dodge(){
			int tmp = (Agility + Toughness) / 4;
			return tmp + dodge;
		}
		public int Aim(){
			int tmp = (Agility + Intelligence) / 4;
			return tmp + aim;
		}
		public int Will(){
			int tmp = (Toughness + Intelligence) / 4;
			return tmp + will;
		}
		public int Resist(){
			int tmp = (Toughness + Special) / 4;
			return tmp + resist;
		}
		public int Magic(){
			int tmp = (Intelligence + Special) / 4;
			return tmp + magic;
		}
		public int Tech(){
			int tmp = (Intelligence + Agility) / 4;
			return tmp + tech;
		}*/
	}
}
using SDL;
using SDLImage;
namespace LAIR{
	public class Anim : Type{
                private Video.Rect position = Video.Rect(){x=0,y=0,w=32,h=32};
                private Video.Rect source = Video.Rect(){x=0,y=0,w=32,h=32};
                private Video.Rect offsetHitBox = Video.Rect(){ x=6, y=6, w=20, h=16 };
                public Anim(Video.Rect rect){
                        base();
                        position = Video.Rect(){x=rect.x,y=rect.y,w=rect.w,h=rect.h};
                        source = Video.Rect(){x=0,y=0,w=rect.w,h=rect.h};
                        stdout.printf("     Rect X: %s,", rect.x.to_string());stdout.printf(" Y: %s", rect.y.to_string());
                        stdout.printf(" W: %s,", rect.w.to_string());stdout.printf(" H: %s", rect.h.to_string());
                        stdout.printf("     Position X: %s,", position.x.to_string());stdout.printf(" Y: %s", position.y.to_string());
                        stdout.printf(" W: %s,", position.w.to_string());stdout.printf(" H: %s", position.h.to_string());
                        stdout.printf("     Source X: %s,", source.x.to_string());stdout.printf(" Y: %s", source.y.to_string());
                        stdout.printf(" W: %s,", source.w.to_string());stdout.printf(" H: %s", source.h.to_string());
                }
                public Anim.Blocked(Video.Rect rect){
                        base.Blocked();
                        position = Video.Rect(){x=rect.x,y=rect.y,w=rect.w,h=rect.h};
                        source = Video.Rect(){x=0,y=0,w=rect.w,h=rect.h};
                        stdout.printf("     Rect X: %s,", rect.x.to_string());stdout.printf(" Y: %s", rect.y.to_string());
                        stdout.printf(" W: %s,", rect.w.to_string());stdout.printf(" H: %s", rect.h.to_string());
                        stdout.printf("     Position X: %s,", position.x.to_string());stdout.printf(" Y: %s", position.y.to_string());
                        stdout.printf(" W: %s,", position.w.to_string());stdout.printf(" H: %s", position.h.to_string());
                        stdout.printf("     Source X: %s,", source.x.to_string());stdout.printf(" Y: %s", source.y.to_string());
                        stdout.printf(" W: %s,", source.w.to_string());stdout.printf(" H: %s", source.h.to_string());
                }
                public Anim.Parameter(Video.Rect rect, string tag){
                        base.Parameter(tag);
                        position = Video.Rect(){x=rect.x,y=rect.y,w=rect.w,h=rect.h};
                        source = Video.Rect(){x=0,y=0,w=rect.w,h=rect.h};
                        stdout.printf("     Rect X: %s,", rect.x.to_string());stdout.printf(" Y: %s", rect.y.to_string());
                        stdout.printf(" W: %s,", rect.w.to_string());stdout.printf(" H: %s", rect.h.to_string());
                        stdout.printf("     Position X: %s,", position.x.to_string());stdout.printf(" Y: %s", position.y.to_string());
                        stdout.printf(" W: %s,", position.w.to_string());stdout.printf(" H: %s", position.h.to_string());
                        stdout.printf("     Source X: %s,", source.x.to_string());stdout.printf(" Y: %s", source.y.to_string());
                        stdout.printf(" W: %s,", source.w.to_string());stdout.printf(" H: %s", source.h.to_string());
                }
                public Anim.ParameterList(Video.Rect rect, List<string> tags){
                        base.ParameterList(tags);
                        position = Video.Rect(){x=rect.x,y=rect.y,w=rect.w,h=rect.h};
                        source = Video.Rect(){x=0,y=0,w=rect.w,h=rect.h};
                        stdout.printf("     Rect X: %s,", rect.x.to_string());stdout.printf(" Y: %s", rect.y.to_string());
                        stdout.printf(" W: %s,", rect.w.to_string());stdout.printf(" H: %s", rect.h.to_string());
                        stdout.printf("     Position X: %s,", position.x.to_string());stdout.printf(" Y: %s", position.y.to_string());
                        stdout.printf(" W: %s,", position.w.to_string());stdout.printf(" H: %s", position.h.to_string());
                        stdout.printf("     Source X: %s,", source.x.to_string());stdout.printf(" Y: %s", source.y.to_string());
                        stdout.printf(" W: %s,", source.w.to_string());stdout.printf(" H: %s", source.h.to_string());
                }
                public Anim.ParameterBlocked(Video.Rect rect, string tag){
                        base.ParameterBlocked(tag);
                        position = Video.Rect(){x=rect.x,y=rect.y,w=rect.w,h=rect.h};
                        source = Video.Rect(){x=0,y=0,w=rect.w,h=rect.h};
                        stdout.printf("     Rect X: %s,", rect.x.to_string());stdout.printf(" Y: %s", rect.y.to_string());
                        stdout.printf(" W: %s,", rect.w.to_string());stdout.printf(" H: %s", rect.h.to_string());
                        stdout.printf("     Position X: %s,", position.x.to_string());stdout.printf(" Y: %s", position.y.to_string());
                        stdout.printf(" W: %s,", position.w.to_string());stdout.printf(" H: %s", position.h.to_string());
                        stdout.printf("     Source X: %s,", source.x.to_string());stdout.printf(" Y: %s", source.y.to_string());
                        stdout.printf(" W: %s,", source.w.to_string());stdout.printf(" H: %s", source.h.to_string());
                }
                public Anim.ParameterListBlocked(Video.Rect rect, List<string> tags){
                        base.ParameterListBlocked(tags);
                        position = Video.Rect(){x=rect.x,y=rect.y,w=rect.w,h=rect.h};
                        source = Video.Rect(){x=0,y=0,w=rect.w,h=rect.h};
                        stdout.printf("     Rect X: %s,", rect.x.to_string());stdout.printf(" Y: %s", rect.y.to_string());
                        stdout.printf(" W: %s,", rect.w.to_string());stdout.printf(" H: %s", rect.h.to_string());
                        stdout.printf("     Position X: %s,", position.x.to_string());stdout.printf(" Y: %s", position.y.to_string());
                        stdout.printf(" W: %s,", position.w.to_string());stdout.printf(" H: %s", position.h.to_string());
                        stdout.printf("     Source X: %s,", source.x.to_string());stdout.printf(" Y: %s", source.y.to_string());
                        stdout.printf(" W: %s,", source.w.to_string());stdout.printf(" H: %s", source.h.to_string());
                }
		public Video.Rect GetPosition(){
                        //stdout.printf("     Position X: %s,", position.x.to_string());stdout.printf(" Y: %s", position.y.to_string());
                        //stdout.printf(" W: %s,", position.w.to_string());stdout.printf(" H: %s ", position.h.to_string());
			return position;
		}
		public Video.Rect GetSource(){
                        //stdout.printf("     Source X: %s,", source.x.to_string());stdout.printf(" Y: %s", source.y.to_string());
                        //stdout.printf(" W: %s,", source.w.to_string());stdout.printf(" H: %s ", source.h.to_string());
                        return source;
		}
		public int GetWidth(){
			return (int) source.w;
		}
                public int GetHalfWidth(){
                        int hW = (int) source.w/2;
                        return hW;
                }
		public int GetHeight(){
			return (int) source.h;
		}
                public int GetHalfHeight(){
                        int hH = (int) source.h/2;
			return hH;
		}
		public int GetX(){
			return (int) position.x;
		}
		public int GetY(){
			return (int) position.y;
		}
                public Video.Rect GetHitBox(){
                        Video.Rect r = Video.Rect(){x=0,y=0,w=0,h=0};
                        if(GetBlock()){
                                if(IsPlayer()){
                                        r = Video.Rect(){ x = GetX() + offsetHitBox.x,
                                                y = GetY() + offsetHitBox.y,
                                                w = GetX() + offsetHitBox.w,
                                                h = GetY() + offsetHitBox.h };
                                }else{
                                        r = position;
                                }
                        }
                        return r;
                }
                public Video.Point GetCenter(){
                        Video.Point coords = Video.Point(){x=GetX()+GetHalfWidth(),y=GetY()+GetHalfHeight()};
                        return coords;
                }
                private double RadiansToDegrees(double radians){
                        double r = (180/Math.PI) * radians;
                        return r;
                }
                public double GetAngle(Video.Point cursorPosition){
                        double degrees = 0.0;
                        Video.Point CP = GetCenter();
                        degrees = RadiansToDegrees((Math.atan2(cursorPosition.x - CP.x, CP.y - cursorPosition.y) + 360) % 360);
                        return degrees;
                }
		public int SetX(int x){
			position.x = x;
			return position.x;
		}
		public int SetY(int y){
			position.y = y;
			return position.y;
		}
	}
}
using SDL;
using SDLMixer;
using SDLTTF;
namespace LAIR{
	class Inventory : Stats{
                public Inventory(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer ){
                        base(corner, Surfaces, music, font, renderer);
                }
                public Inventory.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer){
                        base.Blocked(corner, Surfaces, music, font, renderer);
                }
                public Inventory.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.Parameter(corner, Surfaces, music, font, renderer, tag);
                }
                public Inventory.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(corner, Surfaces, music, font, renderer, tag);
                }
                public Inventory.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(corner, Surfaces, music, font, renderer, tags);
                }
                public Inventory.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(corner, Surfaces, music, font, renderer, tags);
                }
	}
}
using SDL;
using SDLMixer;
using SDLTTF;
namespace LAIR{
	class Move : Inventory{
                public Move(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer ){
                        base(corner, Surfaces, music, font, renderer);
                }
                public Move.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer){
                        base.Blocked(corner, Surfaces, music, font, renderer);
                }
                public Move.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.Parameter(corner, Surfaces, music, font, renderer, tag);
                }
                public Move.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(corner, Surfaces, music, font, renderer, tag);
                }
                public Move.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(corner, Surfaces, music, font, renderer, tags);
                }
                public Move.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(corner, Surfaces, music, font, renderer, tags);
                }
		private void AInput(){
		}
		public int PInput(){
                        int t = 1;
                        Event e;
			//for (Event e = {0}; e.type != EventType.QUIT; Event.poll (out e)) {
                        stdout.printf("     Player is taking a turn : ");
                        while(Event.poll (out e) == 1){
                                stdout.printf(" Checking Event for Player Input\n");
				if (e.type == EventType.KEYDOWN) {
                                        switch(e.key.keysym.sym){
                                                case Input.Keycode.ESCAPE:
                                                        t = 0;
                                                        break;
                                                case Input.Keycode.DOWN:
                                                        t = 2;
                                                        SetY(GetY() + Speed());
                                                        break;
                                                case Input.Keycode.UP:
                                                        t = 3;
                                                        SetY(GetY() - Speed());
                                                        break;
                                                case Input.Keycode.RIGHT:
                                                        t = 4;
                                                        SetX(GetX() + Speed());
                                                        break;
                                                case Input.Keycode.LEFT:
                                                        t = 5;
                                                        SetX(GetX() - Speed());
                                                        break;
                                        }
                                }else if (e.type == EventType.MOUSEMOTION || e.type == EventType.MOUSEBUTTONDOWN || e.type == EventType.MOUSEBUTTONUP){
                                        int x = 0, y = 0;
                                        Input.Cursor.get_state(ref x, ref y);
                                        bool inside = true;
                                        if (inside){
                                                switch (e.type) {
                                                        case EventType.MOUSEMOTION:
                                                                t = 6;
                                                                break;
                                                        case EventType.MOUSEBUTTONDOWN:
                                                                t = 7;
                                                                break;
                                                        case EventType.MOUSEBUTTONUP:
                                                                t = 8;
                                                                break;
                                                }
                                        }
                                }
			}
                        return t;
		}
		public int run(){
                        int r = 1;
			if (IsPlayer()){
				r = PInput();
			}else{
				AInput();
			}
                        return r;
		}
	}
}
using SDL;
using SDLGraphics;
using SDLImage;
using SDLTTF;

namespace LAIR{
	class Text : Sprite{
                public Text(Video.Point corner, List<Video.Surface*> Surfaces, SDLTTF.Font* font, Video.Renderer? renderer){
                        base(corner, Surfaces, renderer);
                }
                public Text.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, SDLTTF.Font* font, Video.Renderer? renderer){
                        base.Blocked(corner, Surfaces, renderer);
                }
                public Text.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.Parameter(corner, Surfaces, renderer, tag);
                }
                public Text.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(corner, Surfaces, renderer, tag);
                }
                public Text.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(corner, Surfaces, renderer, tags);
                }
                public Text.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(corner, Surfaces, renderer, tags);
                }
	}
}
using SDL;
using SDLMixer;

namespace LAIR{
	class Voice : Text{
                public Voice(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer ){
                        base(corner, Surfaces, font, renderer);
                }
                public Voice.Blocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer){
                        base.Blocked(corner, Surfaces, font, renderer);
                }
                public Voice.Parameter(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.Parameter(corner, Surfaces, font, renderer, tag);
                }
                public Voice.ParameterBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, string tag){
                        base.ParameterBlocked(corner, Surfaces, font, renderer, tag);
                }
                public Voice.ParameterList(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterList(corner, Surfaces, font, renderer, tags);
                }
                public Voice.ParameterListBlocked(Video.Point corner, List<Video.Surface*> Surfaces, Music* music, SDLTTF.Font* font, Video.Renderer? renderer, List<string> tags){
                        base.ParameterListBlocked(corner, Surfaces, font, renderer, tags);
                }
	}
}
using SDL;
using SDLMixer;

namespace LAIR{
	class Sound : LairFile {
                private Music music;
		public Sound(string path){
                        base.WithPath(path);
                        Load();
		}
                public Sound.WithAttList(List<string> path){
                        base.WithAttList(path);
                        Load();
		}
                public bool Load(){
                        bool tmp = false;
			if (CheckPath()){
				stdout.printf("Loading the sound to a Music %s \n", GetPath());
				music = new Music(GetPath());
				tmp = true;
			}else{
				stderr.printf("Sound not found at location %s \n", GetPath());
			}
			return tmp;
                }
/*                public bool SoundLoad(string path){
                        SetPath(path);
			bool tmp = false;
			if (CheckPath()){
				stdout.printf("Loading the sound to a Music %s \n", GetPath());
				music = new Music(GetPath());
				tmp = true;
			}else{
				stderr.printf("Sound not found at location %s \n", GetPath());
			}
			return tmp;
                }
                public bool CheckSound(){
			if (CheckPath()){
				return true;
			}else{
				return false;
			}
		}*/
		public Music* GetSound(){
                        Music* tmp = music;
			return tmp;
		}
	}
}using SDL;
using SDLImage;
using SDLGraphics;
using SDLMixer;
using SDLTTF;
namespace LAIR{
	class FileDB {
		private List<Image> imgRes = new List<Image>();
		private List<Sound> sndRes = new List<Sound>();
		private List<Fonts> ttfRes = new List<Fonts>();
		private LairFile imgListPath = null;
		private LairFile sndListPath = null;
		private LairFile ttfListPath = null;
                private GLib.Rand Sorcerer = new GLib.Rand();
		public FileDB(string imgList, string sndList, string ttfList){
			var imgfile = new LairFile.WithPath(imgList);
			stdout.printf("Pre-Loading the game data files.\n");
			if (imgfile.CheckPath()){
				stdout.printf("Pre-Loading the image files(data at %s).\n", imgfile.GetPath());
				imgListPath = imgfile;
			}else{
				stderr.printf ("File '%s' doesn't exist.\n", imgfile.GetPath());
			}
			var sndfile = new LairFile.WithPath(sndList);
			if (sndfile.CheckPath()){
				stdout.printf("Pre-Loading the sound files(data at %s).\n", sndfile.GetPath());
				sndListPath = sndfile;
			}else{
				stderr.printf ("File '%s' doesn't exist.\n", sndfile.GetPath());
			}
			var ttffile = new LairFile.WithPath(ttfList);
			if (ttffile.CheckPath()){
				stdout.printf("Pre-Loading the font files(data at %s).\n", ttffile.GetPath());
				ttfListPath = ttffile;
			}else{
				stderr.printf ("File '%s' doesn't exist.\n", ttffile.GetPath());
			}
			LoadFilesWithTags();
		}
                public bool LoadFilesWithTags(){
			bool tmp = false;
			if (imgListPath.CheckPath()){
				stdout.printf("Loading the image files\n");
                                for (int x = 0; x < imgListPath.LenLineDelimitedConfig(); x++){
                                        List<string> image = imgListPath.GetConfigLine(x);
                                        foreach(string y in image){
                                                stdout.printf("(%s)", y);
                                        }
                                        stdout.printf(".\n");
					imgRes.append(new Image.WithAttList(image));
                                }
				tmp = true;
			}else{
				tmp = false;
			}
			if (sndListPath.CheckPath()){
				stdout.printf("Loading the sound files\n");
                                for (int x = 0; x < sndListPath.LenLineDelimitedConfig(); x++){
                                        List<string> sound = sndListPath.GetConfigLine(x);
                                        foreach(string y in sound){
                                                stdout.printf("(%s)", y);
                                        }
                                        stdout.printf(".\n");
					sndRes.append(new Sound.WithAttList(sound));
                                }
				tmp = true;
			}else{
				tmp = false;
			}
			if (ttfListPath.CheckPath()){
				stdout.printf("Loading the font files\n");
                                for (int x = 0; x < ttfListPath.LenLineDelimitedConfig(); x++){
                                        List<string> font = ttfListPath.GetConfigLine(x);
                                        foreach(string y in font){
                                                stdout.printf("(%s)", y);
                                        }
                                        stdout.printf(".\n");
					ttfRes.append(new Fonts.WithAttList(font, "medium"));
                                }
				tmp = true;
			}else{
				tmp = false;
			}
			return tmp;
		}
/*                public int GetImagesLength(){
                        return (int) imgRes.length();
                }*/
                public int GetSoundsLength(){
                        return (int) sndRes.length();
                }
                public int GetFontsLength(){
                        return (int) ttfRes.length();
                }
                /*private int GetRandomImageIndex(){
                        int tmp = Sorcerer.int_range(0, GetImagesLength());
                        stdout.printf("Random Image from Index #: %s \n", tmp.to_string());
                        return tmp;
                }*/
                private int GetRandomSoundIndex(){
                        int tmp = Sorcerer.int_range(0, GetSoundsLength());
                        stdout.printf("Random Sound from Index # %s \n", tmp.to_string());
                        return tmp;
                }
                private int GetRandomFontIndex(){
                        int tmp = Sorcerer.int_range(0, GetFontsLength());
                        stdout.printf("Random Font from Index #: %s \n", tmp.to_string());
                        return tmp;
                }
/*                private int GetRandomImageIndexByRange(int bottom, int top){
                        int t = top;
                        int b = bottom;
                        if (top > GetImagesLength()){
                                t = GetImagesLength();
                        }
                        if (bottom > 0 ){
                                b = 0;
                        }
                        return Sorcerer.int_range(bottom, top);
                }
                private int GetRandomSoundIndexByRange(int bottom, int top){
                        int t = top;
                        int b = bottom;
                        if (top > GetSoundsLength()){
                                t = GetSoundsLength();
                        }
                        if (bottom > 0 ){
                                b = 0;
                        }
                        return Sorcerer.int_range(bottom, top);
                }
                private int GetRandomFontIndexByRange(int bottom, int top){
                        int t = top;
                        int b = bottom;
                        if (top > GetFontsLength()){
                                t = GetFontsLength();
                        }
                        if (bottom > 0 ){
                                b = 0;
                        }
                        return Sorcerer.int_range(bottom, top);
                }*/
/*                public Video.Surface* GetRandImage(){
                        return imgRes.nth_data(GetRandomImageIndex()).GetImage();
                }
                public Video.Surface* GetRandImageByRange(int bottom, int top){
                        return imgRes.nth_data(GetRandomImageIndexByRange(bottom, top)).GetImage();
                }*/
                public Music* GetRandSound(){
                        return sndRes.nth_data(GetRandomSoundIndex()).GetSound();
                }/*
                public Music* GetRandSoundByRange(int bottom, int top){
                        return sndRes.nth_data(GetRandomSoundIndexByRange(bottom,top)).GetSound();
                }*/
                public SDLTTF.Font* GetRandFont(){
                        return ttfRes.nth_data(GetRandomFontIndex()).GetFont();
                }/*
                public SDLTTF.Font* GetRandFontByRange(int bottom, int top){
                        return ttfRes.nth_data(GetRandomFontIndexByRange(bottom, top)).GetFont();
                }*/
                public List<Video.Surface*> ImageByName(string name){
                        int c = 0;
                        List<int> tmp = new List<int>();
                        List<Video.Surface*> r = new List<Video.Surface*>();
			foreach (Image file in imgRes){
				if (file.HasName(name)){
					tmp.append(c);
				}
                                c++;
			}
                        int top = (int) tmp.length();
                        int index = Sorcerer.int_range(0, top);
                        stdout.printf("Emitting random image from index #: %s \n", tmp.nth_data(index).to_string() );
			r.append(imgRes.nth_data(tmp.nth_data(index)).GetImage());
                        return r;
		}
                public List<Video.Surface*> ImageListByName(string name, int num){
                        int c = 0;
                        List<int> tmp = new List<int>();
                        List<Video.Surface*> r = new List<Video.Surface*>();
			foreach (Image file in imgRes){
				if (file.HasName(name)){
					tmp.append(c);
				}
                                c++;
			}
                        int top = (int) tmp.length();
                        for (int i = 0; i < num; i++){
                                int index = Sorcerer.int_range(0, top);
                                stdout.printf("Emitting random image from index #: %s \n", tmp.nth_data(index).to_string() );
                                r.append(imgRes.nth_data(tmp.nth_data(index)).GetImage());
                        }
			return r;
		}
                /*
		public Video.Surface* ImageByTag(string query){
                        int c = 0;
                        List<int> tmp = new List<int>();
			foreach (Image file in imgRes){
				if (file.HasTag(query)){
					tmp.append(c);
				}
                                c++;
			}
                        int top = (int) tmp.length();
                        int index = Sorcerer.int_range(0, top);
			return imgRes.nth_data(tmp.nth_data(index)).GetImage();
		}*/
                public List<Video.Surface*> BodyByTone(string tone){
                        //int c = 0;
                        List<List<int>> tmp = new List<List<int>>();
                        List<Video.Surface*> r = new List<Video.Surface*>();
                        List<string> Names = new List<string>();
                        Names.append("head"); Names.append("body"); Names.append("leftarms"); Names.append("leftleg"); Names.append("rightarms"); Names.append("rightleg");
                        stdout.printf("Generating a body of %s ", tone);
                        foreach(string name in Names){
                                int c = 0;
                                List<int> t = new List<int>();
                                foreach (Image file in imgRes){
                                        string fullname = tone + name;
                                        if (file.HasName(fullname)){
                                                stdout.printf("found component %s ", fullname);
                                                t.append(c);
                                        }
                                        c++;
                                }
                                tmp.append(t.copy());
                        }
                        foreach(var tm in tmp.copy()){
                                int top = (int) tm.length();
                                int index = Sorcerer.int_range(0, top);
                                stdout.printf(" \n Emitting body component index #: %s \n", tm.nth_data(index).to_string() );
                                r.append(imgRes.nth_data(tm.nth_data(index)).GetImage());
                        }
			return r;
                }/*
                public List<Video.Surface*> BodyByTagList(List<string> query){
                }
                public Music* SoundByName(string name){
			List<Music*> tmp = new List<Music*>();
			foreach (Sound file in sndRes){
				if (file.HasName(name)){
					tmp.append(file.GetSound());
				}
			}
                        int top = (int) tmp.length();
                        int index = Sorcerer.int_range(0, top);
			return tmp.nth_data(index);
		}
		public Music* SoundByTag(string query){
			List<Music*> tmp = new List<Music*>();
			foreach (Sound file in sndRes){
				if (file.HasTag(query)){
					tmp.append(file.GetSound());
				}
			}
                        int top = (int) tmp.length();
                        int index = Sorcerer.int_range(0, top);
			return tmp.nth_data(0);
		}
                public SDLTTF.Font* FontByName(string name){
			List<SDLTTF.Font*> tmp = new List<SDLTTF.Font*>();
			foreach (Fonts file in ttfRes){
				if (file.GetPath() == name){
					tmp.append(file.GetFont());
				}
			}
                        int top = (int) tmp.length();
                        int index = Sorcerer.int_range(0, top);
			return tmp.nth_data(index);
		}
		public SDLTTF.Font* FontByTag(string query){
			List<SDLTTF.Font*> tmp = new List<SDLTTF.Font*>();
			foreach (Fonts file in ttfRes){
				if (file.HasTag(query)){
					tmp.append(file.GetFont());
				}
			}
                        int top = (int) tmp.length();
                        int index = Sorcerer.int_range(0, top);
			return tmp.nth_data(0);
		}*/
	}
}
namespace LAIR{
	public class LairFile : GLib.Object {
		private string Path = null;
		private string Name = null;
                private int Length = 0;
		private List<string> Tags = new List<string>();
//		public LairFile(){
//			Path = null;
//		}
		public LairFile.WithPath(string path){
			Path = SetPath(path);
		}
                public LairFile.WithAttList(List<string> atts){
                        string path = null;
                        List<string> tags = new List<string>();
                        int x = 0;
                        foreach (string attribute in atts){
                                if (x == 0){
                                        path = atts.nth_data(x);
                                        Path = SetPath(path);
                                }else if(x == 1){
                                        Name = atts.nth_data(x);
                                }else{
                                        tags.append(atts.nth_data(x));
                                }
                                x++;
                        }
                        SetTags(tags);
                }
		protected List<string>* SetTags(List<string> tags){
			foreach (string tag in tags){
				if (HasTag(tag) == false){
					Tags.append(tag);
				}
			}
			return Tags;
		}
		public List<string>* GetTags(){
			return Tags;
		}
                public bool HasName(string query){
			bool tmp = false;
                        bool ptd = false;
			if ( query == Name ) {
				tmp = true;
                                if (!ptd){
                                        stdout.printf("Name found in FileDB: %s", query);
                                        ptd = true;
                                }
			}
			return tmp;
		}
		public bool HasTag(string query){
			bool tmp = false;
			foreach (string Tag in Tags){
				if ( query == Tag ) {
					tmp = true;
					break;
				}
			}
			return tmp;
		}
		public string GetPath(){
                        stdout.printf("Getting Path: %s\n", Path);
                        return Path;
		}
		protected string SetPath(string path){
                        string []tmp = path.split(" ", 2);
			if (FileUtils.test(tmp[0], FileTest.EXISTS)) {
				Path = tmp[0];
				stdout.printf("Setting Path: %s\n", Path);
			}else{
				Path = null;
				stdout.printf("Setting Path failed: %s doesn't exist\n", Path);
			}
			return path;
		}
		public bool CheckPath(){
			if (Path != null){
				stdout.printf("Validating Path: %s\n", Path);
				return true;
			}else{
				stdout.printf("Validating Path failed: %s doesn't exist.\n", Path);
				return false;
			}
		}
		public List<string> LoadLineDelimitedConfig(){
			List<string> tmp = new List<string>();
			var file = File.new_for_path(Path);
			stdout.printf("Loading configuration file %s\n", Path);
			if (!file.query_exists ()) {
				stderr.printf ("File '%s' doesn't exist.\n", file.get_path ());
			}
			try {
				var dis = new DataInputStream (file.read());
				string line;
				while ((line = dis.read_line (null)) != null) {
					string []tl = line.split(" ", 2);
					if (FileUtils.test(tl[0], FileTest.EXISTS)) {
						tmp.append(tl[0]);
                                                //tmp.append(line);
						stdout.printf("Loaded Resource: %s\n", tl[0]);
					}else{
						stderr.printf("Failed to load Resource: %s\n", tl[0]);
					}
				}
				stdout.printf("Loaded configuration file %s\n", Path);
			} catch (Error e) {
				error ("%s", e.message);
			}
			return tmp;
		}
                public int LenLineDelimitedConfig(){
			var file = File.new_for_path(Path);
                        int r = 0;
			if (!file.query_exists ()) {
				stderr.printf ("File '%s' doesn't exist.\n", file.get_path ());
			}
                        if (Length == 0){
                                try {
                                        var dis = new DataInputStream (file.read());
                                        string line;
                                        while ((line = dis.read_line (null)) != null) {
                                                r++;
                                        }
                                        stdout.printf("Configuration File Length %s\n", r.to_string());
                                } catch (Error e) {
                                        error ("%s", e.message);
                                }
                                Length = r;
                        }else{
                                r = Length;
                        }
			return r;
		}
                public List<string> GetConfigLine(int lineNum){
                        List<string> tmp = new List<string>();
                        var file = File.new_for_path(Path);
                        stdout.printf("line %s\n", lineNum.to_string());
			if (!file.query_exists ()) {
				stderr.printf ("File '%s' doesn't exist.\n", file.get_path ());
			}
                        try {
				var dis = new DataInputStream (file.read());
				string line;
                                int x = 0;
				while ((line = dis.read_line (null)) != null) {
                                        if ( x == lineNum ){
                                                string []tl = line.split(" ", 0);
                                                if (FileUtils.test(tl[0], FileTest.EXISTS)) {
                                                        foreach(string token in tl){
                                                                tmp.append(token);
                                                        }
                                                        //tmp.append(line);
                                                        stdout.printf("Loaded Resource: %s\n", tl[0]);
                                                }else{
                                                        stderr.printf("Failed to load Resource: %s\n", tl[0]);
                                                }
                                        }
                                        x++;
				}
			} catch (Error e) {
				error ("%s", e.message);
			}
                        return tmp;
                }
	}
}
using SDL;
using SDLImage;
using SDLGraphics;

namespace LAIR{
	public class Image : LairFile {
		private Video.Surface surface;
		public Image(string Path){
			base.WithPath(Path);
			Load();
		}
                public Image.WithAttList(List<string> atts){
                        base.WithAttList(atts);
                        Load();
                }
                public bool Load(){
			bool tmp = false;
			if (CheckPath()){
				stdout.printf("Loading the Image to a Surface %s \n", GetPath());
				surface = SDLImage.load(GetPath());
				tmp = true;
			}else{
				stderr.printf("Image not found at location %s \n", GetPath());
			}
			return tmp;
		}
		public bool ImageLoad(string Path){
			SetPath(Path);
			bool tmp = false;
			if (CheckPath()){
				stdout.printf("Loading the Image to a Surface %s \n", GetPath());
				surface = SDLImage.load(GetPath());
				tmp = true;
			}else{
				stderr.printf("Image not found at location %s \n", GetPath());
			}
			return tmp;
		}
		public bool CheckImage(){
			if (CheckPath()){
				return true;
			}else{
				return false;
			}
		}
		public Video.Surface* GetImage(){
                        Video.Surface* tmp = surface;
			return tmp;
		}
	}
}using SDL;
using SDLTTF;

namespace LAIR{
	class Fonts : LairFile {
		private SDLTTF.Font font;
		private string Size;
		public Fonts(string path, string size){
			base.WithPath(path);
			Size = size;
			Load();
		}
                public Fonts.WithAttList(List<string> path, string size){
			base.WithAttList(path);
			Size = size;
			Load();
		}
                private bool Load(){
			bool tmp = false;
			if (CheckPath()){
				int sz = 12;
				if (Size == "giant"){
					sz = 28;
				}else if (Size == "large"){
					sz = 20;
				}else if (Size == "medium"){
					sz = 12;
				}else if (Size == "small"){
					sz = 10;
				}else if (Size == "tiny"){
					sz = 8;
				}else {
					sz = 12;
				}
				font = new SDLTTF.Font(GetPath(), sz);
				tmp = true;
			}
			return tmp;
		}
/*		private bool FontLoad(string path){
			bool tmp = false;
			SetPath(path);
			if (CheckPath()){
				int sz = 12;
				if (Size == "giant"){
					sz = 28;
				}else if (Size == "large"){
					sz = 20;
				}else if (Size == "medium"){
					sz = 12;
				}else if (Size == "small"){
					sz = 10;
				}else if (Size == "tiny"){
					sz = 8;
				}else {
					sz = 12;
				}
				font = new SDLTTF.Font(GetPath(), sz);
				tmp = true;
			}
			return tmp;
		}
                public bool CheckFont(){
			if (CheckPath()){
				return true;
			}else{
				return false;
			}
		}*/
		public SDLTTF.Font* GetFont(){
                        SDLTTF.Font* tmp = font;
			return tmp;
		}
	}
}